import {messageStore} from "../stores/message";

/**
 * Retour d'un appel serveur en erreur ([RFC9457]).
 *
 * Si le serveur n'est pas configuré pour renvoyer un `ProblemDetails` en cas d'erreur, la réponse sera wrappée dans `ProblemDetails` lorsqu'elle sera rejetée.
 */
export interface ProblemDetails {
    /**
     * A URI reference [RFC3986] that identifies the problem type.
     *
     * This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]).
     *
     * When this member is not present, its value is assumed to be "type" (string) - "about:blank".
     */
    type?: string | "about:blank";

    /**
     * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
     */
    status: number;

    /**
     * A short, human-readable summary of the problem type.
     *
     * It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
     *
     * Si aucun message n'a été enregistré dans le `messageStore` à partir de cette instance, alors ce `title` sera enregistré comme `error` dans le `messageStore`.
     */
    title?: string;

    /**
     * A human-readable explanation specific to this occurrence of the problem.
     *
     * Si renseigné, sera enregistré en premier comme `error` dans le `messageStore`.
     */
    detail?: string;

    /**
     * A URI reference that identifies the specific occurrence of the problem.
     *
     * It may or may not yield further information if dereferenced.
     */
    instance?: string;

    /**
     * Détails supplémentaires sur le problème (erreurs de validation par exemple).
     *
     * Chaque message d'erreur supplémentaire sera enregistré comme `error` dans le `messageStore`, préfixé par sa clé (sauf si c'est `global` ou `globals`).
     */
    errors?: string | string[] | Record<string, string> | Record<string, string[]>;

    /**
     * Problem type definitions MAY extend the problem details object with additional members.
     *
     * Si la clé correspond à un type de message enregistré dans le `messageStore` et que la valeur est un `string`, `string[]`, `Record<string, string>` ou `Record<string, string[]>`,
     * alors les messages seront enregistrés comme du type de leur clé dans le `messageStore` (selon les mêmes règles que `errors`).
     */
    [key: string]: any;
}

/**
 * ProblemDetails traité par Focus, avec les messages qui ont été ajoutés dans le MessageStore.
 */
export interface HandledProblemDetails extends ProblemDetails {
    /** Messages enregistrés dans le MessageStore, dans l'ordre. */
    $messages: {type: string; message: string}[];
}

export function createProblemDetails(status: number, jsonResponse: object): ProblemDetails {
    return {
        ...jsonResponse,
        type: "about:blank",
        status
    };
}

export function handleProblemDetails(problemDetails: ProblemDetails): HandledProblemDetails {
    const messages: Record<string, string[]> = {};

    function add(type: string, ...newMessages: string[]) {
        messages[type] ??= [];
        messages[type].push(...newMessages);
    }

    if (problemDetails.detail) {
        add("errors", problemDetails.detail);
    }

    for (const key in problemDetails) {
        if (["type", "status", "title", "detail", "instance"].includes(key)) {
            continue;
        }

        if (typeof problemDetails[key] === "string") {
            add(key, problemDetails[key]);
        } else if (
            Array.isArray(problemDetails[key]) &&
            problemDetails[key].length > 0 &&
            typeof problemDetails[key][0] === "string"
        ) {
            add(key, ...problemDetails[key]);
        } else if (typeof problemDetails[key] === "object") {
            for (const subkey in problemDetails[key]) {
                if (typeof problemDetails[key][subkey] === "string") {
                    add(
                        key,
                        subkey === "global" || subkey === "globals"
                            ? problemDetails[key][subkey]
                            : `${subkey}: ${problemDetails[key][subkey]}`
                    );
                } else if (
                    Array.isArray(problemDetails[key][subkey]) &&
                    problemDetails[key][subkey].length > 0 &&
                    typeof problemDetails[key][subkey][0] === "string"
                ) {
                    add(
                        key,
                        ...problemDetails[key][subkey].map(m =>
                            subkey === "global" || subkey === "globals" ? m : `${subkey}: ${m}`
                        )
                    );
                }
            }
        }
    }

    const $messages = messageStore.addMessages(messages);

    if ($messages.length === 0 && problemDetails.title) {
        messageStore.addErrorMessage(problemDetails.title);
        $messages.push({type: "error", message: problemDetails.title});
    }

    return {...problemDetails, $messages};
}

/**
 * Vérifie si l'erreur retournée par un appel a bien été traitée et est donc bien au format attendu.
 * @param error L'erreur.
 */
export function isHandledError(error: unknown): error is HandledProblemDetails {
    return typeof error === "object" && !!error && "$messages" in error;
}

/**
 * Vérifie si l'erreur retournée par un appel est une annulation de requête.
 * @param error L'erreur.
 */
export function isAbortError(error: unknown) {
    return error instanceof DOMException && error.name === "AbortError";
}
