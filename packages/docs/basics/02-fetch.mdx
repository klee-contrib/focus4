import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Les bases/Gestion des requêtes" />

# Gestion des requêtes

## `coreFetch`

Focus préconfigure une instance de [`ky`](https://github.com/sindresorhus/ky), lui-même un wrapper à [`window.fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch), qui est accessible via la fonction **`coreFetch`** du module `@focus4/core`.

Cette configuration par défaut permet de :

- Enregistrer toutes les requêtes dans le [`RequestStore`](#requeststore).
- Réessayer automatiquement les requêtes en cas d'erreur réseau (configuré par `coreConfig.retryCountOnFailedFetch`, par défaut à 2).
- Gérer les erreurs structurées renvoyées par le serveur.

### Gestion des erreurs

Si `coreFetch` reçoit une **réponse avec un code de statut en erreur** (4xx-5xx), et si le serveur renvoie une réponse structurée en JSON, alors elle sera interprétée afin de pouvoir **enregistrer automatiquement des messages d'erreur** (à priori) dans le [`messageStore`](/docs/les-bases-gestion-des-messages--docs).

Focus supporte nativement les erreurs qui utilisent la spécification [ProblemDetails](https://www.rfc-editor.org/rfc/rfc7807), mais acceptera aussi des réponses dans un format JSON arbitraire.

Les messages suivants seront générés :

- Si `detail` est renseigné, alors un message de catégorie `error` avec sa valeur sera ajouté.
- La méthode `addMessages` du `messageStore` est appelée avec tous les champs non standard présent dans la réponse (`type`, `status`, `title`,
  `detail` et `instance`). Ces champs peuvent être typés :
    - `string` : enregistre un message de la catégorie du nom du champ.
    - `string[]` : enregistre plusieurs messages de la catégorie du nom du champ.
    - `Record<string, string>` : enregistre un message par valeur du record de la catégorie du nom du champ. Si la clé ne vaut pas `global` ou
      `globals`, il sera préfixé par sa clé (ex : `"{champ}: {message}"`).
    - `Record<string, string[]>` : combinaison des deux cas précédents.
- Si aucun message n'a été enregistré et que `title` est renseigné, alors un message de catégorie `error` avec sa valeur sera ajouté.

Pour rappel, les catégories de messages supportées par le `messageStore` doivent avoir été définies au préalable, si vous voulez gérer autre chose que `error`, `info` ou `warning`. Ce mécanisme permet en revanche de pouvoir gérer des types de messages personnalisés à partir de erreurs serveur personnalisées. Cela peut par la suite être utilisé pour différencier la façon dont les erreurs sont restituées à l'utilisateur (au delà du `MessageCenter` par défaut) par exemple.

Après traitement des erreurs, `coreFetch` renverra une `HTTPDetailedError`, une version complétée de l'`HTTPError` de `ky` avec :

- Une propriété `details` contenant la réponse du serveur, complétée avec `type` et `status` si ce n'était pas un `ProblemDetails`.
- Une propriété `$messages` qui contient la liste des messages générés (dans l'ordre) par la lecture de la réponse.

Vous pouvez utiliser un check `instanceof HTTPDetailedError` dans vos catchs (ou dans `on("error")` sur un formulaire) pour récupérer ces données.

## `RequestStore`

Le `RequestStore` est un store dédié au suivi des requêtes en cours dans l'application.

### Suivi automatique des requêtes

Par défaut, toute requête faite avec `coreFetch` est automatiquement suivie dans ce store. Les requêtes en cours peuvent se récupérer dans `requestStore.pending` et la propriété `requestStore.loading` permet de savoir s'il y au moins une requête encore en cours. Cette propriété peut être utilisée directement pour poser un "spinner" global sur votre application à moindre frais.

### Suivi personnalisé de services

Le `requestStore` dispose également d'une API pour suivre le statut de vos propres services (n'importe quelle fonction retournant une `Promise`) via `requestStore.track` :

```ts
const id = useId(); // ou Math.random().toString() si vous n'est pas dans un composant

/* ---- */

const user = await requestStore.track(id, () => getUser(id)); // Enregistre le service sur cet ID et l'appelle

/* ---- */

requestStore.isLoading(id); // La requête est-elle en cours ?
```

**Plusieurs services peuvent être enregistré sur le même ID de suivi**, ce qui permet de récupérer facilement un état de chargement sur plusieurs services à la fois.

Ce suivi est automatiquement intégré à [`useLoad`](/docs/modèle-métier-chargement-des-données--docs#useload-et-nodeload) et `useFormActions`, qui génèrent un ID de suivi pour leurs services et peuvent y associer d'autres IDs.

_Remarque : Vous pouvez aussi passer un callback en troisième paramètre de `requestStore.track`, appelé avec le résultat de l'appel, pour effectuer des modifications d'état dans la même action que celle qui met à jour l'état de chargement._
