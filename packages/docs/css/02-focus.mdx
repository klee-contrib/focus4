import {Meta} from "@storybook/blocks";

<Meta title="CSS/Le CSS de Focus" />

# Le CSS de Focus

Le CSS de Focus est construit sur du CSS standard, sans framework externe (qu'il soit CSS pur ou CSS-in-JS). Il utilise n√©anmoins extensivement des modules CSS pour organiser le CSS par composant et quelques utilitaires pour en faciliter l'usage et permettre de la surcharge.

Focus utilise √©galement beaucoup de [variables CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties) dans ses composants, en particulier pour tout ce qui est **couleurs** et **dimensions**. Avant de ce pr√©cipiter √† surcharger le CSS, il faut regarder en priorit√© si une surcharge de variable (m√™me locale dans une classe) ne serait pas suffisante.

## Surcharge du CSS Focus

Puisque Focus utilise des modules CSS avec des noms de classes CSS sont autog√©n√©r√©s au build, **il est impossible de surcharger le CSS en red√©finissant des classes CSS globales** (ce qui est enti√®rement voulu).

Focus expose donc sur **chaque composant** une propriet√© **`theme`**, un objet JS dans lequel on peut renseigner l'ensemble des classes CSS utilis√©e par le composant, qui correspond au module CSS correspondant.

### Surcharge locale

Dans son usage le plus simple, elle peut se renseigner via la prop correspondante :

```tsx
import css from "./__style__/button.css";

<Button label="Bouton" theme={{button: css.button}} />;
```

La classe import√©e `css.button` sera **ajout√©e en plus de la classe existante**. Les r√®gles de priorit√© CSS classiques s'appliquent (sp√©cificit√© du s√©lecteur, puis ordre de d√©claration). Focus essaie le plus possible d'avoir des s√©lecteurs les moins pr√©cis possibles, et puisque son CSS devrait √™tre import√© en premier, la surcharge devrait pouvoir se faire simplement.

_Remarque : l'exemple utilise un module CSS, mais `button` prend simplement un `string`, donc n'importe quelle cha√Æne de caract√®res fonctionne ici. Ce syst√®me ne vous oblige pas √† faire des modules CSS, m√™me si c'est fortement recommand√© üòâ._

### Surcharge globale

Via le composant `ThemeProvider`, pos√© par le [`Layout`](/docs/mise-en-page-layout--docs) √† la racine de toute application Focus, il est possible d'ajouter des classes CSS √† **tous les composants pos√©s √† l'int√©rieur** (pour le [`Layout`](/docs/mise-en-page-layout--docs), il s'agira donc d'une surcharge globale).

Les classes CSS se posent via la propri√©t√© `appTheme` :

```tsx
<Layout appTheme={{button: {button: css.button}}} />
```

Ici, on donne le m√™me objet contenant notre classe CSS `button` √† la cl√© `button` de `appTheme`, pour qu'elle s'applique √† **tous les boutons** de l'application.

Chaque composant dispose de sa propre cl√©, et ira chercher le CSS correspondant via le hook `useTheme` dans le contexte du `ThemeProvider`. Ce syst√®me est extensible et peut √™tre utilis√© par vos propres composants avec des cl√©s diff√©rentes, ou pour r√©cup√©rer vos surcharges de CSS Focus dans des composants personnalis√©s. Notez bien tout de m√™me les CSS de base de Focus **ne sont pas ajout√©s dans le `ThemeProvider`** et qu'il faudra les importer et les ajouter manuellement, par exemple :

```tsx
import {buttonCss, ButtonCss} from "@focus4/toolbox";

function MyButton(props: {theme?: ButtonCss}) {
    const theme = useTheme("button", buttonCss, props.theme);
    return <button {/* ... */} />
}
```

Vous pouvez √©galement poser d'autres `ThemeProvider` pour ajouter d'autres classes CSS, en plus de celles du [`Layout`](/docs/mise-en-page-layout--docs), dans certaines parties de votre application. Toutes les classes CSS seront mises bout √† bout sur le composant final.

### Surcharge dans le domaine

Les classes CSS pass√©es dans les props `theme` des composants de domaines dans les domaines (`inputProps`/`selectProps`/`autocompleteProps`/`displayProps`/`labelProps`/`fieldProps`) **ne seront pas surcharg√©es** par celles pass√©es dans un [`patch()`](/docs/mod√®le-m√©tier-personnalisation--docs#patchname-builder) de [`metadata()`](/docs/mod√®le-m√©tier-makefield--docs#metadatametadata), et le tout **ne le sera pas non plus** par les classes pass√©es dans les `inputProps`/`selectProps`... de [`fieldFor`/`selectFor`/`autocompleteFor`](/docs/mod√®le-m√©tier-afficher-des-champs--docs#m√©thodes-de-champs).

Vous pouvez donc, en plus des surcharges locales et globales, d√©finir du CSS personnalis√© qui ne s'appliquera qu'aux composants d'un domaine, sans compromettre une √©ventuelle surcharge locale future.

## Variables CSS

Focus d√©finit des variables CSS √† plusieurs niveaux :

-   Des variables "g√©n√©rales", utilis√©es par la plupart des composants.
-   Des variables par composant, pr√©fix√©es par le nom du composant (ex : pour [`Chip`](/docs/composants-focus4‚àïtoolbox-chip--docs), il s'agit de toutes les variables en `--chip-XXX`).
-   Des variables "communes", typiquement les variables en `--button-XXX` et `--input-XXX`, qui sont partag√©es par un ensemble de composants. (`--button-XXX` par tous les boutons et `--input-XXX` par tous les composants de saisies).

Toutes ces variables sont d√©finies sur `:root` et sont donc des **variables globales**. Les variables peuvent n√©anmoins √™tre surcharg√©es localement dans une classe CSS pour s'appliquer √† tous les √©l√©ments √† l'int√©rieur. Focus utilise cette m√©canique dans certains de ces composants complexes pour modifier certains aspects des composants de base.

**La plupart des personnalisations simples peuvent se faire en modifiant simplement quelques variables CSS**, que √ßa soit globalement ou dans une surcharge de CSS locale. **Priorisez le plus possible de modifier des variables plut√¥t que de r√©√©crire le CSS de Focus**.

Par exemple, si je veux que les champs textes ([`TextField`](/docs/composants-focus4‚àïtoolbox-textfield--docs)) aient un fond blanc au lieu d'√™tre transparents :

```css
/* NE PAS FAIRE CA ! */
.field {
    background-color: white;
}

/** Faire plut√¥t : */
:root {
    --text-field-background-color: rgb(var(--color-white));
}
```

La premi√®re solution n√©cessiterait de cr√©er un fichier de module CSS d√©di√© et de l'importer dans le [`Layout`](/docs/mise-en-page-layout--docs), alors que la seconde est d√©j√† globale et peut √™tre int√©gr√©e dans n'importe quel fichier CSS. De plus, on r√©utilise la variable `--color-white` au lieu de mettre `white` en dur afin de directement g√©rer le cas o√π on voudra red√©finir ce qui est blanc dans l'application (par exemple avec un [th√®me sombre](/docs/css-mode-sombre--docs)... üòâ).

De plus, vous devriez √©galement utiliser des variables pour votre CSS personnalis√© autant que possible et pertinent, pour les m√™mes raisons.

### Variables de couleurs

Focus d√©finit des palettes de couleurs standard (issues de la premi√®re sp√©cification Material Design). Elles prennent la forme `--palette-{color}-{intensity}`, o√π :

-   `intensity` est un chiffre valant `50`, `100`, `200`, `300`, `400`, `500`, `600`, `700`, `800`, `900`, `a100`, `a200`, `a400` ou `a700`
-   `color` une couleur au choix entre `red`, `pink`, `purple`, `deep-purple`, `indigo`, `blue`, `light-blue`, `cyan`, `teal`, `green`, `light-green`, `lime`, `yellow`, `amber`, `orange`, `deep-orange`, `brown`, `grey`, `blue-grey`.

Les deux couleurs `--color-white` et `--color-black` sont aussi d√©finies.

**Toutes ces variables ne sont d√©finies qu'en terme de valeurs RGB**, par exemple `--palette-purple-200` vaut `206, 147, 216`. Pour utiliser la couleur, il faudra donc utiliser la fonction `rgb()` ou `rgba()`, par exemple :

```css
.button {
    color: rgb(var(--palette-purple-200));

    &:hover {
        background-color: rgba(var(--palette-purple-200), 0.2);
    }
}
```

Il existe √©galement 3 couleurs principales, utilis√©es **tr√®s** largement dans les composants Focus (surtout la premi√®re) :

-   `--color-primary`
-   `--color-primary-light`
-   `--color-accent`

Elles sont initialis√©es avec 3 couleurs parmi le choix de palettes, et il s'agira probablement des premi√®res variables √† personnaliser dans votre application.

`--color-primary` est utilis√© en particulier dans tous les composants qui ont besoin d'une couleur pour afficher quelque chose d'actif, et les boutons proposent nativement ces trois couleurs comme choix.

### Autres variables g√©n√©rales

-   `--preferred-font` est la police utilis√©e partout, en particulier dans tous les composants
-   `--shadow-2p` / `--shadow-4p` sont les ombres utilis√©es un peu partout
-   Les variables `--animation-XXX` r√©gissent les types et les temps d'animations
-   Les variables `--font-size-XXX` et `--font-weight-XXX` parlent d'elles-m√™mes
-   Les variables `--z-index-XXX` d√©finissent des valeurs standard de z-index.

### Variables partag√©es

Un certain nombre de variables, en particulier pour d√©finir des couleurs, sont partag√©es entre plusieurs composants :

-   Certaines variables en `--button-XXX` sont utilis√©es dans tous les composants de boutons.
-   Les variables en `--input-XXX` sont partag√©es entre tous les composants de saisie.
-   Les variables en `--focus-ring-X` sont utilis√©s pour g√©rer les indicateurs de focus sur tous les composants.

### Variables locales

Chaque composant peut √©galement d√©finir des variables locales, d√©di√©es √† un composant en particulier. Elles sont en g√©n√©ral identifiables par leur nom en `--{composant}-XXX`.

Toutes les variables locales sont list√©es sur la page de documentation de chaque composant, ainsi que les variables globales et partag√©es utilis√©es dedans.
