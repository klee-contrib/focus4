import {Meta} from "@storybook/addon-docs/blocks";

<Meta title="Modèle métier/Domaines" />

# Domaines

Le **domaine** d'un champ représente le **type de donnée métier** qui lui est associé (par exemple : une date, un numéro de téléphone, un montant...).

_Remarque : le module `@focus4/entities` définit le domaine via le type global `Domain<S>`, qui ne contient qu'un champ unique pour le schéma. C'est le module `@focus4/stores` qui complète cette définition avec les définitions de composants. Si vous utilisez le module `@focus4/entities` en dehors de Focus, vous pourrez donc faire de même._

## Schéma

Un domaine se définit à partir d'un **schéma**, qui permet de définir précisément le **type** d'un champ associé, ainsi que ses règles de **validation**.

Focus utilise **[Zod](https://zod.dev/api)** pour définir ces schémas, qui est la librairie de référence pour définir des schémas de validation en Typescript. En plus de pouvoir gérer les types primitifs de base Javascript tel que `string`, `number` ou `boolean`, Zod dispose aussi de types natifs pour les emails, les uuids, les dates (au format ISO), les entiers... qui sont aussi des `string` ou des `number`, mais avec un format bien particulier.

Ces schémas restent en revanche limités aux domaines, et donc aux champs. Les entités Focus ne peuvent pas être entièrement définies à partir d'un schéma d'objet Zod, car il n'est pas suffisant pour définir l'intégralité de ce qui les constitue. En revanche, un champ peut tout à fait être défini à partir d'un schéma d'objet ou d'array, rien ne force un domaine (et donc un champ) à contenir un type de donnée primitif. Les schémas d'arrays de types primitifs (`string[]`, `number[]` et `boolean[]`) sont d'ailleurs gérés nativement par les composants d'affichage et de saisie multiple de Focus.

Le schéma contraindra le type Typescript "réel" d'un champ de ce domaine (par exemple `z.string()` forcera un champ de type `string`), mais il pourra être **plus précis** (par exemple avec un type `"admin" | "gestionnaire" | "consultant"`).

Un domaine se définit avec la fonction **`domain`**, à partir du schéma associé :

```ts
import z from "zod";

import {domain} from "@focus4/form-toolbox";

const DO_LIBELLE = domain(z.string());
```

## Composants

Un domaine définit **5 composants** pour gérer l'affichage des champs associés :

- Le composant d'affichage en consultation, **`DisplayComponent`**.
- Le composant de saisie classique **`InputComponent`**.
- Le composant de saisie via liste de réference **`SelectComponent`**.
- Le composant de saisie via service d'autocomplétion **`AutocompleteComponent`**.
- Le composant pour le libellé, **`LabelComponent`**

Chacun de ces composants seront appelés avec des props prédéfinies par Focus. Il existe des interfaces de base (`BaseInputProps<S>`, `BaseDisplayProps<S>`...) pour les représenter. Vous pouvez aussi renseigner des props supplémentaires avec les propriétés `inputProps` / `selectProps` / `autocompleteProps` / `displayProps` / `labelProps` (ces props ne peuvent pas surcharger celles renseignées par défaut, en revanche). De plus, la propriété `fieldProps` permettra de passer des props au composant global d'affichage de champ, qui utilisera les 5 autres composants.

En plus de ces composants, un domaine peut définir un `displayFormatter`, pour contrôler la façon dont un champ de ce domaine doit être affiché, dans le cas où ce n'est pas juste la valeur. Il peut être :

- Une fonction de la valeur qui renvoie le texte à afficher
- Une clé de traduction i18n, dans laquelle vous pouvez utiliser la variable `{{value}}` pour référencer la valeur.

Focus inclus des composants par défaut pour tous les usages standards. Le rôle principal de la fonction `domain()` vue précédemment est de renseigner des composants par défaut pour les domaines que vous créez, en fonction de leur schéma. Une définition de domaine à partir du seul schéma devrait être suffisante en première approche pour avoir un fonctionnement correct, puis si ce n'est pas assez, vous pouvez commencer à le personnaliser. De plus, dans la grande majorité des cas :

- Le `DisplayComponent` et le `LabelComponent` par défaut répondent au besoin.
- Un champ n'utilise pas plusieurs types de saisie, donc un seul des 3 composants doit être personnalisé si nécessaire.

Le détail de ce que fait la fonction `domain()` est [décrit par ici](/docs/docs/composants-composants-par-défaut--docs).

## Exemples de domaines personnalisés

```ts
const DO_IBAN = domain(
    z.string().refine(value => iban.isValid(value), {error: "app.iban.invalid"}),
    {
        displayFormatter: value => iban.format(value)
    }
);
const DO_EMAIL = domain(z.email("focus.validation.email"), {inputProps: {icon: "email"}});
const DO_BOOLEEN = domain(z.boolean(), {
    InputComponent: FormSwitch
});
```

## Validation (legacy)

**/!\ Ces validateurs sont dépréciés. La validation est désormais intégrée au schéma du domaine et Zod propose des APIs beaucoup plus avancées que celles-ci. Ils seront (probablement) retirés dans la prochaine version majeure de Focus, vous devriez donc migrer si vous les utilisez encore. /!\\**

Un domaine peut définir **un ou plusieurs validateurs**, qui permettront de vérifier que la valeur d'un champ de ce domaine correspond bien à ce que l'on veut.

Il existe quelques validateurs par défaut :

- Schéma de type `string` :
    - `"string"` : avec `minLength` et `maxLength`, permet de valider une longueur minimale ou maximale.
    - `"date"` : permet de valider que le string est une date ISO valide. (`2024-01-01T00:00:00Z` par exemple).
    - `"email"` : permet de valider que le string est un email valide (via une regex intégrée).
    - `"regex"` : permet de valider que le string est conforme à une regex donnée (dans `regex`).
- Schéma de type `number` :
    - `"number"` : permet de valider que le nombre est compris entre `min` et `max`, et de spécifier un nombre maximum de décimales (`maxDecimals`).

Tous ces validateurs prennent également une propriété `errorMessage`, pour surcharger le message d'erreur par défaut en cas d'erreur de validation.

Si ces validateurs ne vous conviennent pas, vous pouvez toujours définir un validateur comme une **fonction qui retourne un message d'erreur** (ou `undefined` si le champ est valide).

Par exemple :

```ts
// `validator` peut aussi être un array
const DO_LIBELLE = domain(z.string(), {validator: {type: "string", maxLength: 100}});
const DO_DATE = domain(z.string(), {validator: {type: "date"}});
const DO_ENTIER = domain(z.number(), {validator: {type: "number", maxDecimals: 0}});
const DO_IBAN = domain(z.string(), {validator: input => (!ibanChecker.isValid(input) ? "IBAN invalide" : undefined)});
```
