import {Meta} from "@storybook/addon-docs/blocks";

<Meta title="Modèle métier/Domaines" />

# Domaines

Le **domaine** d'un champ représente le **type de donnée métier** qui lui est associé (par exemple : une date, un numéro de téléphone, un montant...).

## Schéma

Un domaine se définit à partir d'un **schéma**, qui permet de définir précisément le **type** d'un champ associé, ainsi que ses règles de **validation**.

Focus utilise **[Zod](https://zod.dev/api)** pour définir ces schémas, qui est la librairie de référence pour définir des schémas de validation en Typescript. En plus de pouvoir gérer les types primitifs de base Javascript tel que `string`, `number` ou `boolean`, Zod dispose aussi de types natifs pour les emails, les uuids, les dates (au format ISO), les entiers... qui sont aussi des `string` ou des `number`, mais avec un format bien particulier.

Ces schémas restent en revanche limités aux domaines, et donc aux champs. Les entités Focus ne peuvent pas être entièrement définies à partir d'un schéma d'objet Zod, car il n'est pas suffisant pour définir l'intégralité de ce qui les constitue. En revanche, un champ peut tout à fait être défini à partir d'un schéma d'objet ou d'array, rien ne force un domaine (et donc un champ) à contenir un type de donnée primitif. Les schémas d'arrays de types primitifs (`string[]`, `number[]` et `boolean[]`) sont d'ailleurs gérés nativement par les composants d'affichage et de saisie multiple de Focus.

Le schéma contraindra le type Typescript "réel" d'un champ de ce domaine (par exemple `z.string()` forcera un champ de type `string`), mais il pourra être **plus précis** (par exemple avec un type `"admin" | "gestionnaire" | "consultant"`).

Un domaine se définit avec la fonction **`domain`**, à partir du schéma associé :

```ts
import z from "zod";

import {domain} from "@focus4/form-toolbox";

const DO_LIBELLE = domain(z.string());
```

## Composants

Un domaine définit **5 composants** pour gérer l'affichage des champs associés :

- Le composant d'affichage en consultation, **`DisplayComponent`**.
- Le composant de saisie classique **`InputComponent`**.
- Le composant de saisie via liste de réference **`SelectComponent`**.
- Le composant de saisie via service d'autocomplétion **`AutocompleteComponent`**.
- Le composant pour le libellé, **`LabelComponent`**

Il existe des composants par défaut pour les 5. Dans la grande majorité des cas :

- Le `DisplayComponent` et le `LabelComponent` par défaut répondent au besoin.
- Un champ n'utilise pas plusieurs types de saisie, donc un seul des 3 composants doit être personnalisé.

Les propriétés `inputProps` / `selectProps` / `autocompleteProps` / `displayProps` / `labelProps` permettent de passer des props par défaut aux composants. La propriété `fieldProps` permettra en plus de passer des props au composant global d'affichage de champ, qui utilisera les 5 autres composants.

La propriété `displayFormatter` est une fonction qui permet de contrôler comme un champ soit être affiché (en texte) et est en général la seule personnalisation à faire pour l'affichage.

Par exemple :

```ts
const DO_DATE = domain({
    type: "string",
    validator: {type: "date"},
    displayFormatter: date => (date ? DateTime.fromISO(date, {zone: "utc"}).toFormat("dd/MM/yyyy") : ""),
    InputComponent: InputDate,
    inputProps: {
        inputFormat: "dd/MM/yyyy",
        inputProps: {icon: "calendar_month"}
    }
});
const DO_EMAIL = domain({type: "string", validator: {type: "email"}, inputProps: {icon: "email"}});
const DO_BOOLEEN = domain({
    type: "boolean",
    displayFormatter: value => (value ? "Oui" : "Non"),
    InputComponent: BooleanRadio
});
```

## Validation (legacy)

**/!\ Ces validateurs sont dépréciés. La validation est désormais intégrée au schéma du domaine et Zod propose des APIs beaucoup plus avancées que celles-ci. Ils seront (probablement) retirés dans la prochaine version majeure de Focus, vous devriez donc migrer si vous les utilisez encore. /!\\**

Un domaine peut définir **un ou plusieurs validateurs**, qui permettront de vérifier que la valeur d'un champ de ce domaine correspond bien à ce que l'on veut.

Il existe quelques validateurs par défaut :

- Schéma de type `string` :
    - `"string"` : avec `minLength` et `maxLength`, permet de valider une longueur minimale ou maximale.
    - `"date"` : permet de valider que le string est une date ISO valide. (`2024-01-01T00:00:00Z` par exemple).
    - `"email"` : permet de valider que le string est un email valide (via une regex intégrée).
    - `"regex"` : permet de valider que le string est conforme à une regex donnée (dans `regex`).
- Schéma de type `number` :
    - `"number"` : permet de valider que le nombre est compris entre `min` et `max`, et de spécifier un nombre maximum de décimales (`maxDecimals`).

Tous ces validateurs prennent également une propriété `errorMessage`, pour surcharger le message d'erreur par défaut en cas d'erreur de validation.

Si ces validateurs ne vous conviennent pas, vous pouvez toujours définir un validateur comme une **fonction qui retourne un message d'erreur** (ou `undefined` si le champ est valide).

Par exemple :

```ts
// `validator` peut aussi être un array
const DO_LIBELLE = domain(z.string(), {validator: {type: "string", maxLength: 100}});
const DO_DATE = domain(z.string(), {validator: {type: "date"}});
const DO_ENTIER = domain(z.number(), {validator: {type: "number", maxDecimals: 0}});
const DO_IBAN = domain(z.string(), {validator: input => (!ibanChecker.isValid(input) ? "IBAN invalide" : undefined)});
```
