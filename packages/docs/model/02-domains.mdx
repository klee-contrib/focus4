import {Meta} from "@storybook/blocks";

<Meta title="ModÃ¨le mÃ©tier/Domaines" />

# Domaines

Le **domaine** d'un champ reprÃ©sente le **type de donnÃ©e mÃ©tier** qui lui est associÃ© (par exemple : une date, un numÃ©ro de tÃ©lÃ©phone, un montant...).

## Type de champ

Un domaine se dÃ©finit au minimum avec un **type de champ**, qui peut Ãªtre :

-   Soit un type primitif : `"string"` / `"number"` / `"boolean"`
-   Soit un type array : `"string-array"` / `"number-array"` / `"boolean-array"`
-   Soit un type objet autre : `"object"`

Le type de champ (sauf `"object"`) contraindra le type Typescript "rÃ©el" d'un champ de ce domaine (`string`/`number`/`boolean`, `string[]`/`number[]`/`boolean[]`), mais il pourra Ãªtre **plus prÃ©cis** (par exemple avec un type `"admin" | "gestionnaire" | "consultant"` pour un domaine `"string"` )

Le type de champ sera nÃ©cessaire pour d'autres fonctionnalitÃ©s (puisqu'on ne peut pas se baser sur le type Typescript ðŸ˜‰)

Un domaine se dÃ©finit avec la fonction **`domain`**, et au moins le type de champ associÃ© :

```ts
import {domain} from "@focus4/forms";

const DO_LIBELLE = domain({type: "string"});
```

## Validation

Un domaine peut dÃ©finir **un ou plusieurs validateurs**, qui permettront de vÃ©rifier que la valeur d'un champ de ce domaine correspond bien Ã  ce que l'on veut.

Il existe quelques validateurs par dÃ©faut :

-   Type de champ `"string"` :
    -   `"string"` : avec `minLength` et `maxLength`, permet de valider une longueur minimale ou maximale.
    -   `"date"` : permet de valider que le string est une date ISO valide. (`2024-01-01T00:00:00Z` par exemple).
    -   `"email"` : permet de valider que le string est un email valide (via une regex intÃ©grÃ©e).
    -   `"regex"` : permet de valider que le string est conforme Ã  une regex donnÃ©e (dans `regex`).
-   Type de champ `"number"` :
    -   `"number"` : permet de valider que le nombre est compris entre `min` et `max`, et de spÃ©cifier un nombre maximum de dÃ©cimales (`maxDecimals`).

Tous ces validateurs prennent Ã©galement une propriÃ©tÃ© `errorMessage`, pour surcharger le message d'erreur par dÃ©faut en cas d'erreur de validation.

Si ces validateurs ne vous conviennent par, vous pouvez toujours dÃ©finir un validateur comme une **fonction qui retourne un message d'erreur** (ou `undefined` si le champ est valide).

Par exemple :

```ts
// `validator` peut aussi Ãªtre un array
const DO_LIBELLE = domain({type: "string", validator: {type: "string", maxLength: 100}});
const DO_DATE = domain({type: "string", validator: {type: "date"}});
const DO_ENTIER = domain({type: "number", validator: {type: "number", maxDecimals: 0}});
const DO_IBAN = domain({
    type: "string",
    validator: input => (!ibanChecker.isValid(input) ? "IBAN invalide" : undefined)
});
```

## Composants

Un domaine dÃ©finit **5 composants** pour gÃ©rer l'affichage des champs associÃ©s :

-   Le composant d'affichage en consultation, **`DisplayComponent`**.
-   Le composant de saisie classique **`InputComponent`**.
-   Le composant de saisie via liste de rÃ©ference **`SelectComponent`**.
-   Le composant de saisie via service d'autocomplÃ©tion **`AutocompleteComponent`**.
-   Le composant pour le libellÃ©, **`LabelComponent`**

Il existe des composants par dÃ©faut pour les 5. Dans la grande majoritÃ© des cas :

-   Le `DisplayComponent` et le `LabelComponent` par dÃ©faut rÃ©pondent au besoin.
-   Un champ n'utilise pas plusieurs types de saisie, donc un seul des 3 composants doit Ãªtre personnalisÃ©.

Les propriÃ©tÃ©s `inputProps` / `selectProps` / `autocompleteProps` / `displayProps` / `labelProps` permettent de passer des props par dÃ©faut aux composants. La propriÃ©tÃ© `fieldProps` permettra en plus de passer des props au composant global d'affichage de champ, qui utilisera les 5 autres composants.

La propriÃ©tÃ© `displayFormatter` est une fonction qui permet de contrÃ´ler comme un champ soit Ãªtre affichÃ© (en texte) et est en gÃ©nÃ©ral la seule personnalisation Ã  faire pour l'affichage.

Par exemple :

```ts
const DO_DATE = domain({
    type: "string",
    validator: {type: "date"},
    displayFormatter: date => (date ? DateTime.fromISO(date, {zone: "utc"}).toFormat("dd/MM/yyyy") : ""),
    InputComponent: InputDate,
    inputProps: {
        inputFormat: "dd/MM/yyyy",
        inputProps: {icon: "calendar_month"}
    }
});
const DO_EMAIL = domain({type: "string", validator: {type: "email"}, inputProps: {icon: "email"}});
const DO_BOOLEEN = domain({
    type: "boolean",
    displayFormatter: value => (value ? "Oui" : "Non"),
    InputComponent: BooleanRadio
});
```
