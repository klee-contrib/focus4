import {Meta} from "@storybook/addon-docs/blocks";

<Meta title="Mod√®le m√©tier/Champs et entit√©s" />

# Champs et entit√©s

## D√©finition d'un champ

Un champ se d√©fini avec :

- Un nom (`name`).
- Un domaine (`domain`).
- Son caract√®re obligatoire (`isRequired`).
- Un libell√© (`label`).
- Un commentaire (facultatif) (`comment`).
- Un type Typescript, si plus pr√©cis que celui port√© par le domaine.

Exemple de champ :

```ts
const libelle = {
    type: "field", // Indiquera qu'il s'agit d'un champ (dans une entit√©)
    name: "libelle",
    domain: DO_LIBELLE, // La r√©f√©rence vers le domaine
    isRequired: true,
    label: "securite.profil.libelle",
    comment: "securite.comments.profil.libelle"
};
```

### Type Typescript (`FieldEntry`/`FieldEntry2`)

Le type Typescript de Focus qui repr√©sente un champ est le type `FieldEntry`. C'est un type g√©n√©rique avec 8 param√®tres (!!) parce qu'il doit contenir (dans l'ordre) :

- Le type de champ du domaine.
- Le type Typescript du champ (qui est contraint par le type de champ du domaine).
- Le type du composant de saisie classique (`InputComponent`).
- Le type du composant de saisie via liste de r√©ference (`SelectComponent`).
- Le type du composant de saisie via service d'autocompl√©tion (`AutocompleteComponent`).
- Le type du composant d'affichage en consultation, (`DisplayComponent`).
- Le type du composant pour le libell√©, (`LabelComponent`).
- Le type du composant de champ (qui est lui toujours le m√™me, `Field`).

Une version simplif√©e de ce type, `FieldEntry2`, existe pour r√©duire ce nombre de param√®tres √† 2 :

- Le type du domaine (c'est lui qui porte en r√©alit√© les 7 autres types...).
- Le type du Typescript du champ (qui est d'ailleurs facultatif s'il n'a pas besoin d'√™tre plus pr√©cis que le type de champ du domaine).

Vous n'avez en g√©n√©ral pas √† vous soucier de ce "d√©tail" d'impl√©mentation et de la complexit√© apparente des types de champs. Vous risquez cependant de le voir passer au d√©tour de certains messages d'erreurs Typescript lorsque vous ne passez pas les bons champs aux bons endroits...

## D√©finition d'une entit√©

Une entit√© se d√©finit comme un objet, qui peut contenir :

- Des champs (`type: "field"`).
- Une autre entit√© (`type: "object"`).
- Une liste d'une autre entit√© (`type: "list"`).
- Une liste de lui-m√™me (`type: "recursive-list"`).

_Remarque : une entit√© ne peut pas se r√©f√©rencer elle-m√™me (en dehors de la liste r√©cursive), y compris via une r√©f√©rence dans une autre entit√© r√©f√©renc√©e._

Par exemple :

```ts
const ProfilReadEntity = {
    id: {
        type: "field",
        name: "id",
        domain: DO_ID,
        isRequired: false,
        label: "securite.profil.id"
    },
    libelle: {
        type: "field",
        name: "libelle",
        domain: DO_LIBELLE,
        isRequired: true,
        label: "securite.profil.libelle"
    },
    utilisateurs: {
        type: "list",
        entity: UtilisateurItemEntity,
        isRequired: true
    }
};
```

Il n'est pas vraiment conseill√© d'√©crire ces d√©finitions √† la main, car cela serait fastidieux et sujet √† erreurs, en particulier car pour la majeure partie d'entre-elles elles doivent correspondre √† une API de votre serveur.

Vous devriez utiliser un outil de mod√©lisation externe pour les g√©n√©rer. Il parait que [TopModel](https://klee-contrib.github.io/topmodel) est un outil id√©al pour √ßa et il dispose d'un [g√©n√©rateur](https://klee-contrib.github.io/topmodel/#/generator/js) d√©di√© pour ces entit√©s Focus üòâ.

_Remarque : le g√©n√©rateur TopModel g√©n√®re aussi la d√©finition de type Typescript correspondante √† l'entit√©, et utilise le type `FieldEntry2` pour les champs._

_Remarque 2 : pour que le g√©n√©rateur TopModel g√©n√®re `isRequired` sur les compositions (ce qui n'est pas un `"field"`), il faut activer l'option `extendedCompositions`. Elle ajoutera aussi `label`, mais cette propri√©t√© n'est pas utilis√©e par Focus. Focus accepte que `isRequired` ne soit pas renseign√©, dans ce cas il sera √† `true` par d√©faut._
